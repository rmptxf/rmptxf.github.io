[{"content":"To get started with the nRF52 Development, you need to have a development kit as also download and install the necessary software tools.\nGet a Development Kit: In order to run/test your applications code, you need to have a development kit. the dev-kit consists of a development board, where your targeted SOC (system on chip)is soldered to with all the necessary components needed for its proper working, aditionally to some user-programmable buttons, leds, header pins\u0026hellip; so you can easilly and quikly test your applications. It also consists of a J-Link OB IC (Interface MCU) used to debug and download compiled codes into the SOC\u0026rsquo;s Flash memory.\nThe nRF52 series features 6 SOCs:\nnRF52810, nRF52811, nRF52820, nRF52832, nRF52833, nRF52840.\n The nRF52DK supports development for the nRF52832 and the nRF52810 SOCs. The nRF52833DK supports development for the nRF52833 and the nRF52820 SOCs. The nRF52840DK supports development for the nRF52840 and the nRF52811 SOCs.  To buy a Dev-kit, refer to the NordicSemi distrubutors WebPage.\nDownload and Install the necessary tools: After getting your Development kit, you need to download and install the necessary software tools in order to start your development journey.\nDownload and Install an IDE : SEGGER Embedded Studio (SES) is a Powerful IDE to use, also recomended by NordicSemi and offers a free Commercial license for the use with NordicSemi products.\nYou\u0026rsquo;ll be notified (with instructions) to request and install your free license on your first launch.\nYou can download the IDE in the segger download page. It is available for: Windows 32/64 bit, Linux 32/64 bit and macOS.\nDownload the nRF5 SDK: The nRF5 Software development kit is a set of tools, modules, libraries, example codes\u0026hellip; that are necessary for building applications for the nRF51 and nRF52 series.\nAt the time of writing this tutorial (16/04/2020), the latest version is nRF5SDK160098a08e2 (16.00).\nDownload your nRF5 SDK copy in the nRF-SDK Download page.\nDownload and Install the nRF Command Line Tools: The nRF Command Line Tools is used for development, programming and debugging of Nordic Semiconductor\u0026rsquo;s nRF51, nRF52, nRF53 and nRF91 Series devices.\nDownload it for your OS in the nRF command line tools Download page.\nDownload and Install nRFConnect Desktop app: It\u0026rsquo;s not a necessary tool (at least at the start), but you will definitly need it in further stages.\nDownload it in the NordicSemi Download Webpage.\nGet a BLE explorer app for your SmartPhone: When developping a ble based application, having a testing app installed in your SmartPhone will be very helpful. You can then easilly test and debug your ble services and characteristics. I found these apps very helpful:\n  LightBlue® — Bluetooth Low Energy. The app is available for IOS and Android.\n  BLE Scanner. The app is available for IOS and Android.\n  nRF Connect for Mobile. The app is available for IOS and Android.\n  ","description":"Getting started with nRF52 Development.","id":0,"section":"tutorials","tags":null,"title":"Get started","uri":"/tutorials/getting-started/"},{"content":"After getting your dev-kit and installing all the necessary software tools, this should be the time to run/test some example codes from the SDK. We\u0026rsquo;ll be using the peripheral/blinky example.\nOpen the blinky project with SES IDE: For me, i have extracted the SDK .Zip file in C:\\nRF5-SDK\\nRF5-SDK16, so the blinky example folder location will be in C:\\nRF5-SDK\\nRF5-SDK16\\examples\\peripheral\\blinky.\nIn this folder you will have 2 options, either directly upload the precompiled hex file (hex folder) (you will need nrf connect desktop app for that), or open the source code files (pca\u0026hellip; folders) so you can update and upload your code easilly with Segger Embedded Studio (SES), and this is what we\u0026rsquo;ll be doing.\nWhich (pca \u0026hellip; folder) to open depends on your dev-kit:\n If you\u0026rsquo;re using the nRF52 DK, it should be PCA10040. If you\u0026rsquo;re using the nRF52840 DK, it should be PCA10056. If you\u0026rsquo;re using the nRF52833 DK, it should be PCA10100.[ Most of the examples does not support this dev-kit, but as the on-board SOC (nRF52833) is very similar to the nRF52840 SOC, you can use the PCA10056 folder also for this dev-kit. But, you still need to :\n1 Change the board config from to PCA10100.\n2 Change the board definition in preprocessor definitions.\n3 Adjust the FLASH and RAM sizes. ]  For me, I have the nRF52840 DK, so i\u0026rsquo;ll open the PCA10056 folder, then blank, then the IDE (SES), then open the EMPROJECT File. SES IDE should then launch and load the blinky project source files.\nPlug your board: To connect your Dev-kit to your PC, use the Left USB connector (J2) . And please make sure you use a good USB cable (it is the most common source of issues like (board not detected, issues on uploading\u0026hellip;), unfortunaltely the dev-kit doesn\u0026rsquo;t come with one.\nHere is the nRF52840 DK with two USB connectors. the other usb connector (down to the right) (J3) is hard wired to the USB pins of the SOC, and serves as the USB link for applications such as a USB keyboard/mouse\u0026hellip; so this is the USB connector that you\u0026rsquo;ll be using to test/run these type of applications.\nThe Left USB connector (J2) is wired directly to the Jlink-OB IC (Interface MCU), that in its turn is wired to both the on-board SOC and to the debug out ports.\nThe Jlink-OB IC automatically selects the SOC that will program. It will first check the debug out ports, if it didn\u0026rsquo;t detect any SOC on these ports, it will then switch to the on board SOC.\nIf you\u0026rsquo;re using the nRF52840 DK or the nRF52833 DK, make sure these switches are set to default states:\n SW8: the power switch, is set to ON: you can use this switch to turn ON/OFF your dev-kit, without unpluging the USB cable. very handy in case you\u0026rsquo;re trying to add/update some wiring connections. SW9: the nRF power source, is set to VDD: this is where to select the power source of the on board SOC. and as we use the upper usb connector, the SOC will get powered via VDD. SW6: make sure it is set to default: this switch desconnects the SOC from the Jlink-OB IC if it is set to nRF ONLY.  If you are using the nRF52 DK You will only have the power switch, so just turn that ON and you\u0026rsquo;ll be all set.\nNB: You will notice a 5V pin available on most of the dev-kits (if not all) even if it is out of the acceptable volatge range for the on-board SOC. For these dev-kits, make sure you don\u0026rsquo;t connect that pin to any of the SOC pins. You can still use it for powering certain components such as a small servo. Just make sure your SOC pins voltage remain in the acceptable range.\nYou can check your SOC specs, in the product specification page.\nFor the lastest (as of 18/05/2020) product specification versions:\n nRF52810_PS_v1.3. nRF52811_PS_v1.0. nRF52820_OPS_v0.7.1. nRF52832_PS_v1.4. nRF52833_PS_v1.2. nRF52840_PS_v1.1.  Build and Run the blinky app: If everything is good, when you plug your dev-kit your OS should detect it and a green LED close to the (Interface MCU) should light up. Now lets move into SES, where we have lunched our blinky example.\nYour SES user interface should look something like this:\nIf this is your first time launching the SES IDE, you will be Notified to install your Free commercial license. Follow the instructions provided to do that.\nThe project\u0026rsquo;s Folder/Files are on the left side. Go to the application folder, and open the main.c file (if it\u0026rsquo;s not already opened).\nGo to the Build menu and select Build and Run. This should build your code and upload it directly to your dev-kit SOC\u0026rsquo;s flash memory.\nIf the blinky app was uploaded successfully, you will notice the on-board LEDS turns ON one after the other and turn back OFF one after the other at a fixed period of 1 second.\nUpdate the blinky app: Now lets play with this example code and change the period of the blinking. let\u0026rsquo;s make it small a 0.5 second, so the leds blinks faster.\nIn the main() function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int main(void)\r{\r/* Configure board. */\rbsp_board_init(BSP_INIT_LEDS);\r/* Toggle LEDs. */\rwhile (true)\r{\rfor (int i = 0; i \u0026lt; LEDS_NUMBER; i++)\r{\rbsp_board_led_invert(i);\rnrf_delay_ms(1000);\r}\r}\r}   You\u0026rsquo;ll notice that this function nrf_delay_ms(), is the responsible for the delay between the ON and OFF of the leds (the blinking). its value is set to 1000 ms = 1 second. will change it to 0.5 second = 500 ms.\n1  nrf_delay_ms(500); // changed the 1000 to 500  \nNow, save your main.c file with a Left_Control+S (if you are on windows), or just open the File menu and hit Save main.c or Save All (this will save any modified file).\nNext, go to the Build menu, and hit Build And Run.\nNow have a look at the LEDS, the blinking period should be updated and the ON/OFF sequence should be faster.\n","description":"Run your first app (blinky).","id":1,"section":"tutorials","tags":null,"title":"Run your first app","uri":"/tutorials/run-your-first-app/"},{"content":"Your nRF52 development kit already comes with 4 user-programmable buttons and 4 leds built in.\nIn this tutorial we\u0026rsquo;ll be looking into how to read these buttons states and control the leds. This should give you a better understanding on how to read and control pins states.\nBefore getting started: Make sure you have installed all the necessary software tools, and have a dev-kit.\nIf you haven\u0026rsquo;t already done that, please follow the Get started tutorial.\nGetting started: For building the testing code, we\u0026rsquo;ll be starting with the blinky project located under the peripheral examples.\ni\u0026rsquo;m using the nRF52840DK (PCA10056), so i\u0026rsquo;ll launch the EM PROJECT FILE in ../examples/peripheral/blinky/pca10056/blank/ses. This should luanch the SES IDE, and load the blinky project files.\nNext, open your main.c file under the Application folder in the SES project file explorer on the left and scroll down to the main() function.\nIt should look like :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int main(void)\r{\r/* Configure board. */\rbsp_board_init(BSP_INIT_LEDS);\r/* Toggle LEDs. */\rwhile (true)\r{\rfor (int i = 0; i \u0026lt; LEDS_NUMBER; i++)\r{\rbsp_board_led_invert(i);\rnrf_delay_ms(1000);\r}\r}\r}   Before jumping into the code, I first want you to know about this handy feature in the SES:\n On any function or included header file, you can jump into the code behind it by using the Go To Definition or Go To Declaration options available in the Mouse right click menu. And you can also keep doing it when ever you need to. If you get lost and want to come back, use the Arrow keys on the top left.  In our main() we have this function bsp_board_led_invert(i);, this function is the responsible for the LED state inverting. lets see the code behind it using the SES Go to Definition feature.\nThis will open the boards.c file, and you can see the code behind that function there. So this is the function that actualy gets executed nrf_gpio_pin_toggle(m_board_led_list[led_idx]), after it made sure the led (index) we try to invert its state is less than the LEDS_NUMBER. ASSERT(led_idx \u0026lt; LEDS_NUMBER);\nThe LEDS_NUMBER is how many LEDs we have defined. This parameter aditionally to any board related parameter are already defined in the board file.\nIf we move up in the boards.c file, you\u0026rsquo;ll see that it includes a boards.h header file. let\u0026rsquo;s jump into it.\nIn the boards.h header file, you\u0026rsquo;ll see lot of board definitions includes grayed (Not used, cause they are not defined).But, you\u0026rsquo;ll see that #include \u0026ldquo;pca10056.h\u0026rdquo; (our board file) is not.\nA Go To Defenition on that file will open it. This is where almost all your board pins are defined. Some pins are not included, cause they are not available as GPIO pins by default. Example : (P0.0), and (P0.1): they are connected to the 32.768 kHz crystal (nrf52840dk).\nPlease check your Dev-kit hardawre description for more details.\n  nRF52 DK hardware description.\n  nRF52833 DK hardware description.\n  nRF52840 DK hardware description.\n  The Dev-kit Buttons/Leds Pins: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // LEDs definitions for PCA10056\r#define LEDS_NUMBER 4\r\r#define LED_1 NRF_GPIO_PIN_MAP(0,13)\r#define LED_2 NRF_GPIO_PIN_MAP(0,14)\r#define LED_3 NRF_GPIO_PIN_MAP(0,15)\r#define LED_4 NRF_GPIO_PIN_MAP(0,16)\r#define LED_START LED_1\r#define LED_STOP LED_4\r\r#define LEDS_ACTIVE_STATE 0\r\r#define LEDS_LIST { LED_1, LED_2, LED_3, LED_4 }\r\r#define LEDS_INV_MASK LEDS_MASK\r\r#define BSP_LED_0 13\r#define BSP_LED_1 14\r#define BSP_LED_2 15\r#define BSP_LED_3 16\r\r#define BUTTONS_NUMBER 4\r\r#define BUTTON_1 11\r#define BUTTON_2 12\r#define BUTTON_3 24\r#define BUTTON_4 25\r#define BUTTON_PULL NRF_GPIO_PIN_PULLUP\r\r#define BUTTONS_ACTIVE_STATE 0\r\r#define BUTTONS_LIST { BUTTON_1, BUTTON_2, BUTTON_3, BUTTON_4 }\r\r#define BSP_BUTTON_0 BUTTON_1\r#define BSP_BUTTON_1 BUTTON_2\r#define BSP_BUTTON_2 BUTTON_3\r#define BSP_BUTTON_3 BUTTON_4   The pins numbring starts as follows :\n P0.0 to P0.31 \u0026mdash;\u0026mdash;-\u0026gt; 0 to 31 . P1.0 to P1.15 \u0026mdash;\u0026mdash;-\u0026gt; 32 to 47 .  The NRF_GPIO_PIN_MAP() function is used to convert the Px.y notation to a pin number.\nSo NRF_GPIO_PIN_MAP(0,13) = 13 , NRF_GPIO_PIN_MAP(1,0) = 32 and so on.\nIn our board file (pca10056.h):\n  We have 4 Leds and we can either use (LED_1, LED_2, LED_3, LED_4), or (BSP_LED_0, BSP_LED_1, BSP_LED_2, BSP_LED_3) as leds variables.\nThe LEDs are active LOW, means a LOW signal (0v) will turn them ON.\n  And we have 4 Buttons and we can either use (BUTTON_1, BUTTON_2, BUTTON3, BUTTON_4), or (BSP_BUTTON_0, BSP_BUTTON_1, BSP_BUTTON_2, BSP_BUTTON_3) as buttons variables.\nThe Buttons are active on LOW, a press will short the button pin to the ground (Pulled-up internally).\n  Buiding our application code: In this example code we\u0026rsquo;ll try to control each led with a button. So we\u0026rsquo;ll try to turn ON/OFF the LED1 with the Button1: a press turns it ON and a release turns it OFF, and so on for the others.\nHere is the example code, you can now press/release on any of your board buttons to control the related led.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  #include \u0026lt;stdbool.h\u0026gt;\r#include \u0026lt;stdint.h\u0026gt;\r#include \u0026#34;nrf_delay.h\u0026#34;\r#include \u0026#34;boards.h\u0026#34;\r\rint button1_state, button2_state, button3_state, button4_state;\r/**\r* @brief Function for application main entry.\r*/\rint main(void)\r{\r// Configure the buttons as inputs and Pull them Up\r nrf_gpio_cfg_input(BUTTON_1,NRF_GPIO_PIN_PULLUP);\rnrf_gpio_cfg_input(BUTTON_2,NRF_GPIO_PIN_PULLUP);\rnrf_gpio_cfg_input(BUTTON_3,NRF_GPIO_PIN_PULLUP);\rnrf_gpio_cfg_input(BUTTON_4,NRF_GPIO_PIN_PULLUP);\r// Configure the leds as outputs\r nrf_gpio_cfg_output(LED_1);\rnrf_gpio_cfg_output(LED_2);\rnrf_gpio_cfg_output(LED_3);\rnrf_gpio_cfg_output(LED_4);\r// Turn the LEDs OFF\r nrf_gpio_pin_set(LED_1); nrf_gpio_pin_set(LED_2); nrf_gpio_pin_set(LED_3); nrf_gpio_pin_set(LED_4);\rwhile (true)\r{\r// Read the buttons states  button1_state = nrf_gpio_pin_read(BUTTON_1);\rbutton2_state = nrf_gpio_pin_read(BUTTON_2);\rbutton3_state = nrf_gpio_pin_read(BUTTON_3);\rbutton4_state = nrf_gpio_pin_read(BUTTON_4);\rif(button1_state == 0) nrf_gpio_pin_clear(LED_1); // _clear() set the pin to LOW  else nrf_gpio_pin_set(LED_1); // _set() set the pin to HIGH \rif(button2_state == 0) nrf_gpio_pin_clear(LED_2);\relse nrf_gpio_pin_set(LED_2);\rif(button3_state == 0) nrf_gpio_pin_clear(LED_3);\relse nrf_gpio_pin_set(LED_3);\rif(button4_state == 0) nrf_gpio_pin_clear(LED_4);\relse nrf_gpio_pin_set(LED_4);\r}\r}   Notes: In the example we built, you can notice that all the control functions are in the while() loop, means that the SOC will keep reading the buttons pins all the time, and when ever a button is pressed it will turn the related led ON, and OFF when released.\nThe problem here is that the SOC will drain more power in this process, and this is a critical fearture here especillay for low power applications.\nA better way to acheive the same result with low power consumption, is by using interrupts.\n","description":"How to read the buttons states and control the leds.","id":2,"section":"tutorials","tags":null,"title":"Buttons and leds","uri":"/tutorials/buttons-and-leds/"}]