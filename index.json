[{"content":"After getting your development kit and installing all the necessary software tools, this should be the time to run/test some examples from the nRF5_SDK. I will be using the blinky example under the peripheral examples folder.\nOpen the blinky project with SES IDE: I have extracted the nRF5_SDK .Zip file in C:\\nRF\\nRF5_SDK\\v17.0.0\\, so the blinky example folder location will be in C:\\nRF\\nRF5_SDK\\v17.0.0\\examples\\peripheral\\blinky.\nIn this folder you will have 2 options:\n Directly upload the precompiled hex file (hex folder) (you will need nRFconnect desktop app for that). Open the source code files (pca\u0026hellip; folders). With this option you will be able to update and flash the application easilly using SES, and this is what I will be doing.  Which (pca \u0026hellip; folder) to open depends on your dev-kit.\n Note: This is also printed on Top of the On-board Debugger MCU of your Development kit.\n  Note: Most of the nRF5_SDK examples does not support the nRF52833-DK , but as the on-board SOC (nRF52833) is very similar to the (nRF52840) you can use the PCA10056 folder also for this dev-kit. But, you still need to :\n Change the board config from PCA10056 to PCA10100. Change the board definition in preprocessor definitions. Adjust the FLASH and RAM sizes.    Note: The nRF5_SDK v12.3.0 is the latest SDK to support the nRF51 family. So planing on using these SOCs will require using the nRF5_SDK v12.3.0 or older versions.\n For me, I have the nRF52840-DK, so i\u0026rsquo;ll open the PCA10056 folder, then blank (The example doesn\u0026rsquo;t use a Softdevice), then the IDE (SES), then open the EMPROJECT file. (SES) should then launch and load the blinky project source files.\nPlug your board: To connect your Dev-kit to your PC, use the Left USB connector (J2) . And please make sure you use a good USB cable (it is the most common source of issues like (board not detected, issues on uploading\u0026hellip;), unfortunaltely the dev-kit doesn\u0026rsquo;t come with one.\nHere is the nRF52840-DK with two USB connectors. the other usb connector (down to the right) (J3) is hard wired to the USB pins of the SOC, and serves as the USB link for applications such as a USB keyboard/mouse\u0026hellip; so this is the USB connector that you\u0026rsquo;ll be using to test/run these type of applications.\nThe Left USB connector (J2) is wired directly to the On-board Debugger, that in its turn is wired to both the on-board SOC and to the debug out ports.\nThe On-board Debugger automatically selects the SOC that will connect to. It will first check the debug out ports, if it didn\u0026rsquo;t detect any SOC on these ports, it will then switch to the on board SOC.\nIf you\u0026rsquo;re using the nRF52840-DK or the nRF52833-DK, make sure these switches are set to the default states:\n SW8: the power switch, is set to ON: You can use this switch to turn ON/OFF your dev-kit, without unpluging the USB cable. very handy in case of adding/updating some wiring connections on the fly. SW9: the nRF power source, is set to VDD: This is where to select the power source of the on board SOC. As we use the left usb connector, the SOC will get powered via VDD. SW6: make sure it is set to default: This switch disconnects the SOC from the On-board J-link Debugger if it is set to nRF ONLY.   Note: If you are using other development kits like the nRF52 DK, You will only have the power switch, so just turn that ON and you will be all set.\n Build and Run the blinky app: If everything is good, when you plug your dev-kit your OS should detect it and a green LED close to the On-board Debugger should light up. Now lets move into SES, where we have lunched our blinky example.\nYour SES user interface should look something like this:\nThe project\u0026rsquo;s Folder/Files are on the left side. Go to the Application folder, and open the main.c file (if it\u0026rsquo;s not already opened).\nGo to the Build menu and select Build and Run. This should build your application and flash it directly to your development kit SOC.\nIf the blinky app was uploaded successfully, you will notice the on-board LEDs turns ON one after the other, then turns back OFF one after the other at a fixed period of 1 second.\nUpdate the blinky app: 1. Update the blinking period: Now lets play with this example by updating the period of the blinking. let\u0026rsquo;s make it small a 0.5 second, so the leds blinks faster.\nIn the main() function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int main(void)\r{\r/* Configure board. */\rbsp_board_init(BSP_INIT_LEDS);\r/* Toggle LEDs. */\rwhile (true)\r{\rfor (int i = 0; i \u0026lt; LEDS_NUMBER; i++)\r{\rbsp_board_led_invert(i);\rnrf_delay_ms(1000);\r}\r}\r}   You\u0026rsquo;ll notice that this function nrf_delay_ms(), is the responsible for the delay between the ON and OFF of the leds (the blinking). Its value is set to 1000 ms = 1 second. Will update it to 0.5 second = 500 ms.\n1  nrf_delay_ms(500); // changed the 1000 to 500  \nNow, save your main.c file with a Left_Control+S (if you are on windows), or just open the File menu and hit Save main.c or Save All (this will save any unsaved modified files).\nNext, go to the Build menu, and hit Build And Run.\nNow have a look at the LEDs, the blinking period should be updated and the ON/OFF sequence should be faster.\n2. Update the blinking sequence: Now lets change the blinking sequence to start from LED4 to LED1. The bsp_board_led_invert(i) function inverts the LEDs based on there index. The index starts from 0 to 3. So the LED1 index is 0, and the LED4 will be 3.\nFor that, the for() loop should start from 3 to 0.\nThe LEDS_NUMBER is the total LEDs on the boards, which is 4.\nSo we should start from i= LEDS_NUMBER-1 with the condition of i \u0026gt;= 0 so we can still execute the 0 index.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int main(void)\r{\r/* Configure board. */\rbsp_board_init(BSP_INIT_LEDS);\r/* Toggle LEDs. */\rwhile (true)\r{\rfor (int i = LEDS_NUMBER-1; i \u0026gt;= 0; i--)\r{\rbsp_board_led_invert(i);\rnrf_delay_ms(1000);\r}\r}\r}   3. LEDs all Blinking at the same time: Now lets make all the LEDs blinks at the same time.\nLooking into the boards.c file -that you can access under Borad definition folder in the Project files to the left- there are these two functions bsp_board_leds_on() and bsp_board_leds_off. These two function can turn On/Off all the LEDs in the Board. The new main()function would look like:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  int main(void)\r{\r/* Configure board. */\rbsp_board_init(BSP_INIT_LEDS);\r/* Toggle all the LEDs. */\rwhile (true)\r{\rbsp_board_leds_on();\rnrf_delay_ms(1000);\rbsp_board_leds_off();\rnrf_delay_ms(1000);\r}\r}   4. Blink a specific LED: Now lets blink a specific LED.\nLooking again into the boards.c file, there are these two functions bsp_board_led_on(uint32_t led_idx) and bsp_board_led_off(uint32_t led_idx). These two function can turn On/Off a specific LED, based on its index. Let\u0026rsquo;s blink the LED1 which its index is 0.\n Note: If you try to use an out of range index ( \u0026gt; LEDS_NUMBER-1), the application execution will assert.\n The new main()function would look like:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  int main(void)\r{\r/* Configure board. */\rbsp_board_init(BSP_INIT_LEDS);\r/* Toggle all the LEDs. */\rwhile (true)\r{\rbsp_board_led_on(0);\rnrf_delay_ms(1000);\rbsp_board_led_off(0);\rnrf_delay_ms(1000);\r}\r}    Note: The borad.c file includes many other functions that you can use to control the LEDs states as also read the Buttons states.\n ","description":"Test the peripheral/blinky example.","id":0,"section":"tutorials","tags":null,"title":"Blinky Test","uri":"https://nrf5dev.com/tutorials/test-blinky-app/"},{"content":"Your nRF52 development kit already comes with 4 user-programmable buttons and 4 leds built in.\nIn this tutorial we\u0026rsquo;ll be looking into how to read these buttons states and control the leds. This should give you a better understanding on how to read and control pins states.\nGetting started: For building the testing code, we\u0026rsquo;ll be starting with the blinky project located under the peripheral examples.\ni\u0026rsquo;m using the nRF52840-DK (PCA10056), so i\u0026rsquo;ll launch the EM PROJECT FILE in ../examples/peripheral/blinky/pca10056/blank/ses. This should luanch the SES IDE, and load the blinky project files.\nNext, open your main.c file under the Application folder in the SES project file explorer on the left and scroll down to the main() function.\nIt should look like :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int main(void)\r{\r/* Configure board. */\rbsp_board_init(BSP_INIT_LEDS);\r/* Toggle LEDs. */\rwhile (true)\r{\rfor (int i = 0; i \u0026lt; LEDS_NUMBER; i++)\r{\rbsp_board_led_invert(i);\rnrf_delay_ms(1000);\r}\r}\r}   Before jumping into the code, I first want you to know about this handy feature in SES:\n On any function or included header file, you can jump into the code behind it by using the Go To Definition or Go To Declaration options available in the Mouse right click menu. And you can also keep doing it when ever you need to. If you get lost and want to come back, use the Arrow keys on the top left.\n In our main() we have this function bsp_board_led_invert(i);, this function is the responsible for the LED state inverting. lets see the code behind it using the SES Go to Definition feature.\nThis will open the boards.c file, and you can see the code behind that function there. So this is the function that actualy gets executed nrf_gpio_pin_toggle(m_board_led_list[led_idx]), after it made sure the led (index) we try to invert its state is less than the LEDS_NUMBER. ASSERT(led_idx \u0026lt; LEDS_NUMBER);\nThe LEDS_NUMBER is how many LEDs we have defined. This parameter aditionally to any board related parameter are already defined in the board file.\nIf we move up in the boards.c file, you\u0026rsquo;ll see that it includes a boards.h header file. let\u0026rsquo;s jump into it.\nIn the boards.h header file, you\u0026rsquo;ll see lot of board definitions includes grayed (Not used, cause they are not defined).But, you\u0026rsquo;ll see that #include \u0026ldquo;pca10056.h\u0026rdquo; (our board file) is not.\nA Go To Defenition on that file will open it. This is where almost all your board pins are defined. Some pins are not included, cause they are not available as GPIO pins by default. Example : (P0.0), and (P0.1): they are connected to the 32.768 kHz crystal (nrf52840dk).\nPlease check your Dev-kit hardawre description for more details.\n  nRF52 DK hardware description.\n  nRF52833 DK hardware description.\n  nRF52840 DK hardware description.\n  The Dev-kit Buttons/Leds Pins:  pca10056.h file.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // LEDs definitions for PCA10056\r#define LEDS_NUMBER 4\r\r#define LED_1 NRF_GPIO_PIN_MAP(0,13)\r#define LED_2 NRF_GPIO_PIN_MAP(0,14)\r#define LED_3 NRF_GPIO_PIN_MAP(0,15)\r#define LED_4 NRF_GPIO_PIN_MAP(0,16)\r#define LED_START LED_1\r#define LED_STOP LED_4\r\r#define LEDS_ACTIVE_STATE 0\r\r#define LEDS_LIST { LED_1, LED_2, LED_3, LED_4 }\r\r#define LEDS_INV_MASK LEDS_MASK\r\r#define BSP_LED_0 13\r#define BSP_LED_1 14\r#define BSP_LED_2 15\r#define BSP_LED_3 16\r\r#define BUTTONS_NUMBER 4\r\r#define BUTTON_1 11\r#define BUTTON_2 12\r#define BUTTON_3 24\r#define BUTTON_4 25\r#define BUTTON_PULL NRF_GPIO_PIN_PULLUP\r\r#define BUTTONS_ACTIVE_STATE 0\r\r#define BUTTONS_LIST { BUTTON_1, BUTTON_2, BUTTON_3, BUTTON_4 }\r\r#define BSP_BUTTON_0 BUTTON_1\r#define BSP_BUTTON_1 BUTTON_2\r#define BSP_BUTTON_2 BUTTON_3\r#define BSP_BUTTON_3 BUTTON_4  \n The pins numbring is as follows:\n  P0.0 to P0.31 \u0026mdash;\u0026mdash;\u0026gt; 0 to 31 . P1.0 to P1.15 \u0026mdash;\u0026mdash;\u0026gt; 32 to 47 .   The NRF_GPIO_PIN_MAP() function is used to convert the Px.y notation to a pin number.\nSo NRF_GPIO_PIN_MAP(0,13) = 13 , NRF_GPIO_PIN_MAP(1,0) = 32 and so on.\nIn our board file (pca10056.h):\n  We have 4 Leds and we can either use (LED_1, LED_2, LED_3, LED_4), or (BSP_LED_0, BSP_LED_1, BSP_LED_2, BSP_LED_3) as leds variables.\nThe LEDs are active LOW, means a LOW signal (0v) will turn them ON.\n  And we have 4 Buttons and we can either use (BUTTON_1, BUTTON_2, BUTTON3, BUTTON_4), or (BSP_BUTTON_0, BSP_BUTTON_1, BSP_BUTTON_2, BSP_BUTTON_3) as buttons variables.\nThe Buttons are active on LOW, a press will short the button pin to the ground (Pulled-up internally).\n  Buiding our application code: In this example code we\u0026rsquo;ll try to control each led with a button. So we\u0026rsquo;ll try to turn ON/OFF the LED1 with the Button1: a press will turn it ON and a release will turn it OFF, and same for the others.\nHere is the example code. You can now press/release on any of your development kit buttons to control the related led.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  #include \u0026lt;stdbool.h\u0026gt;\r#include \u0026lt;stdint.h\u0026gt;\r#include \u0026#34;nrf_delay.h\u0026#34;\r#include \u0026#34;boards.h\u0026#34;\r\rint button1_state, button2_state, button3_state, button4_state;\r/**\r* @brief Function for application main entry.\r*/\rint main(void)\r{\r// Configure the buttons as inputs and Pull them Up\r nrf_gpio_cfg_input(BUTTON_1,NRF_GPIO_PIN_PULLUP);\rnrf_gpio_cfg_input(BUTTON_2,NRF_GPIO_PIN_PULLUP);\rnrf_gpio_cfg_input(BUTTON_3,NRF_GPIO_PIN_PULLUP);\rnrf_gpio_cfg_input(BUTTON_4,NRF_GPIO_PIN_PULLUP);\r// Configure the leds as outputs\r nrf_gpio_cfg_output(LED_1);\rnrf_gpio_cfg_output(LED_2);\rnrf_gpio_cfg_output(LED_3);\rnrf_gpio_cfg_output(LED_4);\r// Turn the LEDs OFF\r nrf_gpio_pin_set(LED_1); nrf_gpio_pin_set(LED_2); nrf_gpio_pin_set(LED_3); nrf_gpio_pin_set(LED_4);\rwhile (true)\r{\r// Read the buttons states  button1_state = nrf_gpio_pin_read(BUTTON_1);\rbutton2_state = nrf_gpio_pin_read(BUTTON_2);\rbutton3_state = nrf_gpio_pin_read(BUTTON_3);\rbutton4_state = nrf_gpio_pin_read(BUTTON_4);\rif(button1_state == 0) nrf_gpio_pin_clear(LED_1); // _clear() set the pin to LOW  else nrf_gpio_pin_set(LED_1); // _set() set the pin to HIGH \rif(button2_state == 0) nrf_gpio_pin_clear(LED_2);\relse nrf_gpio_pin_set(LED_2);\rif(button3_state == 0) nrf_gpio_pin_clear(LED_3);\relse nrf_gpio_pin_set(LED_3);\rif(button4_state == 0) nrf_gpio_pin_clear(LED_4);\relse nrf_gpio_pin_set(LED_4);\r}\r}    Notes: In the example we built, you can notice that all the control functions are in the while() loop, means that the SOC will keep reading the buttons pins all the time, and whenever a button is pressed it will turn the related led ON, and OFF when released.\nThe problem here is that the SOC will drain lot of power in this process, and this is a critical fearture for low power applications.\nA better way to acheive the same result with low power consumption, is by using interrupts.\n ","description":"How to read the buttons states and control the leds with the nRF5.","id":1,"section":"tutorials","tags":null,"title":"Buttons and leds","uri":"https://nrf5dev.com/tutorials/buttons-and-leds/"}]