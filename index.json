[{"content":"In this Tutorial I will walk you throught all the necessary steps that you need to follow, in order to get started with the nRF5 development.\n1: Get a Development Kit In order to run/test your applications, you need to have a development kit. the dev-kit consists of a development board, where your targeted SOC (system on chip) is soldered to with all the necessary components needed for its proper working. Aditionally to some user-programmable buttons, leds, header pins\u0026hellip; so you can easilly and quikly test your applications. It also comes with a J-Link Debugger IC (Interface MCU) allowing programming and debugging both the on-board SoC and external SoCs through the debug out headers.\nThe nRF5 consists of 3 series: the nRF51 series, the nRF52 series and the nRF53 series.\nThe nRF51 series: The nRF51 series features 4 SOCs :nRF51822, nRF51422, nRF51824, nRF51802.\n CPU : 16MHz, Cortex-M0. RAM : (Min: 16KB, Max: 32KB). FLASH : (Min: 128KB, Max: 256KB). RF : 2.4 GHz proprietary, BLE 4.2 and ANT*. (*nRF51422 Only). Data rates : 2 Mbps, 1 Mbps, 250 kbps. TX Power : +4 dBm. Peripherals : UART, SPI, TWI. ADC resolution : 10-bit. Encryption : 128-bit AES CCM. AEC Q100 Qualification : (Grade 2) nRF51824 Only. nRF51-DK \u0026amp; nRF51-Dongle Onboard SOC : nRF51422.  The nRF51-DK can be used to develop applications for all the above SOCs.\nThe nRF51-Dongle can also be used, but only for the nRF51822, nRF51422, nRF51824 SoCs.\nThe dongle comes with a On-Borad SEGGER J-Link debugger, same as the Dev-kit. So you will not need to have an external debugger for flashing your application.But as you note in the picture, the dongle has few pins exposed. So planing to use lot of pins might be of an issue. For that i suggest getting a dev-kit instead, then maybe get a dongle.\nThe nRF52 series: The nRF52 series features 7 SOCs :nRF52805, nRF52810, nRF52811, nRF52820, nRF52832, nRF52833, nRF52840.\n4 Development kits added to one Dongle, can be used to develop applications for the abouve SOCs. The nRF52-DK, the nRF52833-DK, the nRF52840-DK and the nRF52840-Dongle.\nnRF52-DK: The nRF52-DK supports the development for the nRF52805, the nRF52810 and the nRF52832.\n CPU : 64MHz, Cortex-M4. FPU support : nRF52832. RAM : (Min: 24KB, Max: 64KB). FLASH : (Min: 192KB, Max: 256KB). RF : 2.4 GHz proprietary, BLE 5.2. Bluetooth mesh : nRF52832. Data rates : 2 Mbps, 1 Mbps. TX power : +4 dBm . Peripherals : UART, SPI, TWI. PWM \u0026amp; PDM : nRF52810, nRF52832. I2S : nRF52832. NFC-A : nRF52832. ADC resolution : 12-bit. Encryption : 128-bit AES. Onboard SOC : nRF52832.  nRF52833-DK: The nRF52833-DK suports development for the nRF52820 and the nRF52833.\n CPU : 64MHz, Cortex-M4. FPU support : nRF52833. RAM : (Min: 32KB, Max: 128KB). FLASH : (Min: 256KB, Max: 512KB). RF : 2.4 GHz proprietary, BLE 5.2, Bluetooth mesh, Thread, Zigbee, Bluetooth Direction Finding. Data rates : 2 Mbps, 1 Mbps, Long Range. TX power : +8 dBm . Peripherals : UART, SPI, TWI, FS USB 2.0. PWM, PDM, HS-SPI, I2S, NFC : nRF52833. QDEC : nRF52820. ADC resolution : 12-bit. Encryption : 128-bit AES (nRF52820), 128-bit AES CCM (nRF52833). Extended temperature range : -40 to 105 °C (nRF52820). Onboard SOC : nRF52833.  nRF52840-DK: The nRF52833-DK suports development for the nRF52811 and the nRF52840.\n CPU : 64MHz, Cortex-M4. FPU support : nRF52840. RAM : (Min: 24KB, Max: 256KB). FLASH : (Min: 192KB, Max: 1MB). RF : 2.4 GHz proprietary, BLE 5.2, Thread. Bluetooth Direction Finding : nRF52811. Zigbee \u0026amp; Bluetooth Mesh : nRF52840. Data rates : 2 Mbps, 1 Mbps, Long Range. TX power : +4 dBm (nRF52811), +8 dBm ((nRF52840)). Peripherals : UART, SPI, TWI, PWM, PDM. HS-SPI, I2S, NFC,FS USB2.0 : nRF52840. ADC resolution : 12-bit. Encryption : 128-bit AES (nRF52811), 128-bit AES CCM \u0026amp; Arm CryptoCell-310 (nRF52840). Onboard SOC : nRF52840.  nRF52840-Dongle: The nRF52840-Dongle is similar to the nRF52840-DK, but it doesn\u0026rsquo;t have an on-borad debugger, so the debugging is not supported. The dongle can be programmed by USB using the nRFConnect desktop app.\nThe nRF53 series: The nRF53 series features 1 SOC :nRF5340.\nThe nRF5340-PDK can be used to develop applications for the abouve SOC.\n CPU : 128/64MHz, Cortex-M33. RAM : 512/64KB. FLASH : 1MB/256KB. RF : 2.4 GHz proprietary, BLE 5.2, Bluetooth Direction Finding\nBluetooth mesh, Thread, Zigbee. Data rates : 2 Mbps, 1 Mbps. Peripherals : HS-SPI, QSPI, NFC,FS USB 2.0. Encryption : Advanced Security. Onboard SOC : nRF5340. Extended operating Temperature: 105°C.  Buying a Development kit:  Note: If you\u0026rsquo;re just getting started, I do recommend getting an nRF52 based development kit. If you think your application may need the USB peripheral feature, choose the nRF52840-DK, if not choose the nRF52-DK. Most of the nRF5 SDK examples are already supporting those two Development kits, So it will be easy to get started than if you start with the others. Other development kits require making some changes to the examples, to make them work for those development kits.\n To buy a Development kit, refer to its Webpage and click on Buy now.\n2: Install the necessary software tools After getting your Development kit, you need to download and install the necessary software tools.\nThe IDE The latest version (v17) of the nRF5 SDK supports: ARM GCC, IAR, Keil5 and SES.\nSEGGER Embedded Studio (SES) is a Powerful IDE to use, also recomended by NordicSemi and offers a Free Commercial license for the use with its products.\nYou can download the IDE in the SEGGER download page. It is available for: Windows 32/64 bit, Linux 32/64 bit and macOS.\nThe nRF5 SDK The nRF5 SDK is a set of tools, modules, libraries, examples \u0026hellip; that are necessary for building applications for the nRF51 and nRF52 series.\nAt the time of writing this tutorial 8th of August 2020, the latest version is nRF5_SDK_17.0.0_9d13099 (17.00).\nDownload your nRF5 SDK copy in the nRF-SDK Download page\nOnce you click on the Download, Move to the bottom of the page.\nThe nRF Command Line Tools The nRF Command Line Tools is used for development, programming and debugging of Nordic Semiconductor\u0026rsquo;s nRF51, nRF52, nRF53 and nRF91 Series devices.\nDownload the latest vesrion for your OS in the nRF command line tools Download page.\nThe nRFConnect Desktop app It\u0026rsquo;s not a necessary tool (at least at the start), but you will definitly need it in further stages.\nDownload the latest verssion for your OS, in the NordicSemi Download Webpage.\nA BLE explorer app for your SmartPhone When developping a BLE based application, having a testing app installed in your SmartPhone will be very helpful to debug your application before building the actual app.\nI found these apps very helpful:\n  LightBlue® — Bluetooth Low Energy. The app is available for IOS and Android.\n  BLE Scanner. The app is available for IOS and Android.\n  nRF Connect for Mobile. The app is available for IOS and Android.\n  ","description":"Getting started with nRF5 Development : The Software tools and the hardware that you need to have.","id":0,"section":"tutorials","tags":null,"title":"Get started","uri":"/tutorials/getting-started/"},{"content":"After getting your dev-kit and installing all the necessary software tools, this should be the time to run/test some example codes from the SDK. We\u0026rsquo;ll be using the peripheral/blinky example.\nOpen the blinky project with SES IDE: For me, i have extracted the SDK .Zip file in C:\\nRF5-SDK\\nRF5-SDK16, so the blinky example folder location will be in C:\\nRF5-SDK\\nRF5-SDK16\\examples\\peripheral\\blinky.\nIn this folder you will have 2 options, either directly upload the precompiled hex file (hex folder) (you will need nrf connect desktop app for that), or open the source code files (pca\u0026hellip; folders) so you can update and upload your code easilly with Segger Embedded Studio (SES), and this is what we\u0026rsquo;ll be doing.\nWhich (pca \u0026hellip; folder) to open depends on your dev-kit:\n If you\u0026rsquo;re using the nRF52 DK, it should be PCA10040. If you\u0026rsquo;re using the nRF52840 DK, it should be PCA10056. If you\u0026rsquo;re using the nRF52833 DK, it should be PCA10100.[ Most of the examples does not support this dev-kit, but as the on-board SOC (nRF52833) is very similar to the nRF52840 SOC, you can use the PCA10056 folder also for this dev-kit. But, you still need to :\n1 Change the board config from to PCA10100.\n2 Change the board definition in preprocessor definitions.\n3 Adjust the FLASH and RAM sizes. ]  For me, I have the nRF52840 DK, so i\u0026rsquo;ll open the PCA10056 folder, then blank, then the IDE (SES), then open the EMPROJECT File. SES IDE should then launch and load the blinky project source files.\nPlug your board: To connect your Dev-kit to your PC, use the Left USB connector (J2) . And please make sure you use a good USB cable (it is the most common source of issues like (board not detected, issues on uploading\u0026hellip;), unfortunaltely the dev-kit doesn\u0026rsquo;t come with one.\nHere is the nRF52840 DK with two USB connectors. the other usb connector (down to the right) (J3) is hard wired to the USB pins of the SOC, and serves as the USB link for applications such as a USB keyboard/mouse\u0026hellip; so this is the USB connector that you\u0026rsquo;ll be using to test/run these type of applications.\nThe Left USB connector (J2) is wired directly to the Jlink-OB IC (Interface MCU), that in its turn is wired to both the on-board SOC and to the debug out ports.\nThe Jlink-OB IC automatically selects the SOC that will program. It will first check the debug out ports, if it didn\u0026rsquo;t detect any SOC on these ports, it will then switch to the on board SOC.\nIf you\u0026rsquo;re using the nRF52840 DK or the nRF52833 DK, make sure these switches are set to default states:\n SW8: the power switch, is set to ON: you can use this switch to turn ON/OFF your dev-kit, without unpluging the USB cable. very handy in case you\u0026rsquo;re trying to add/update some wiring connections. SW9: the nRF power source, is set to VDD: this is where to select the power source of the on board SOC. and as we use the upper usb connector, the SOC will get powered via VDD. SW6: make sure it is set to default: this switch desconnects the SOC from the Jlink-OB IC if it is set to nRF ONLY.  If you are using the nRF52 DK You will only have the power switch, so just turn that ON and you\u0026rsquo;ll be all set.\nNB: You will notice a 5V pin available on most of the dev-kits (if not all) even if it is out of the acceptable volatge range for the on-board SOC. For these dev-kits, make sure you don\u0026rsquo;t connect that pin to any of the SOC pins. You can still use it for powering certain components such as a small servo. Just make sure your SOC pins voltage remain in the acceptable range.\nYou can check your SOC specs, in the product specification page.\nFor the lastest (as of 18/05/2020) product specification versions:\n nRF52810_PS_v1.3. nRF52811_PS_v1.0. nRF52820_OPS_v0.7.1. nRF52832_PS_v1.4. nRF52833_PS_v1.2. nRF52840_PS_v1.1.  Build and Run the blinky app: If everything is good, when you plug your dev-kit your OS should detect it and a green LED close to the (Interface MCU) should light up. Now lets move into SES, where we have lunched our blinky example.\nYour SES user interface should look something like this:\nIf this is your first time launching the SES IDE, you will be Notified to install your Free commercial license. Follow the instructions provided to do that.\nThe project\u0026rsquo;s Folder/Files are on the left side. Go to the application folder, and open the main.c file (if it\u0026rsquo;s not already opened).\nGo to the Build menu and select Build and Run. This should build your code and upload it directly to your dev-kit SOC\u0026rsquo;s flash memory.\nIf the blinky app was uploaded successfully, you will notice the on-board LEDS turns ON one after the other and turn back OFF one after the other at a fixed period of 1 second.\nUpdate the blinky app: Now lets play with this example code and change the period of the blinking. let\u0026rsquo;s make it small a 0.5 second, so the leds blinks faster.\nIn the main() function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int main(void)\r{\r/* Configure board. */\rbsp_board_init(BSP_INIT_LEDS);\r/* Toggle LEDs. */\rwhile (true)\r{\rfor (int i = 0; i \u0026lt; LEDS_NUMBER; i++)\r{\rbsp_board_led_invert(i);\rnrf_delay_ms(1000);\r}\r}\r}   You\u0026rsquo;ll notice that this function nrf_delay_ms(), is the responsible for the delay between the ON and OFF of the leds (the blinking). its value is set to 1000 ms = 1 second. will change it to 0.5 second = 500 ms.\n1  nrf_delay_ms(500); // changed the 1000 to 500  \nNow, save your main.c file with a Left_Control+S (if you are on windows), or just open the File menu and hit Save main.c or Save All (this will save any modified file).\nNext, go to the Build menu, and hit Build And Run.\nNow have a look at the LEDS, the blinking period should be updated and the ON/OFF sequence should be faster.\n","description":"Run your first app (blinky).","id":1,"section":"tutorials","tags":null,"title":"Run your first app","uri":"/tutorials/run-your-first-app/"},{"content":"Your nRF52 development kit already comes with 4 user-programmable buttons and 4 leds built in.\nIn this tutorial we\u0026rsquo;ll be looking into how to read these buttons states and control the leds. This should give you a better understanding on how to read and control pins states.\nBefore getting started: Make sure you have installed all the necessary software tools, and have a dev-kit.\nIf you haven\u0026rsquo;t already done that, please follow the Get started tutorial.\nGetting started: For building the testing code, we\u0026rsquo;ll be starting with the blinky project located under the peripheral examples.\ni\u0026rsquo;m using the nRF52840DK (PCA10056), so i\u0026rsquo;ll launch the EM PROJECT FILE in ../examples/peripheral/blinky/pca10056/blank/ses. This should luanch the SES IDE, and load the blinky project files.\nNext, open your main.c file under the Application folder in the SES project file explorer on the left and scroll down to the main() function.\nIt should look like :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int main(void)\r{\r/* Configure board. */\rbsp_board_init(BSP_INIT_LEDS);\r/* Toggle LEDs. */\rwhile (true)\r{\rfor (int i = 0; i \u0026lt; LEDS_NUMBER; i++)\r{\rbsp_board_led_invert(i);\rnrf_delay_ms(1000);\r}\r}\r}   Before jumping into the code, I first want you to know about this handy feature in the SES:\n On any function or included header file, you can jump into the code behind it by using the Go To Definition or Go To Declaration options available in the Mouse right click menu. And you can also keep doing it when ever you need to. If you get lost and want to come back, use the Arrow keys on the top left.  In our main() we have this function bsp_board_led_invert(i);, this function is the responsible for the LED state inverting. lets see the code behind it using the SES Go to Definition feature.\nThis will open the boards.c file, and you can see the code behind that function there. So this is the function that actualy gets executed nrf_gpio_pin_toggle(m_board_led_list[led_idx]), after it made sure the led (index) we try to invert its state is less than the LEDS_NUMBER. ASSERT(led_idx \u0026lt; LEDS_NUMBER);\nThe LEDS_NUMBER is how many LEDs we have defined. This parameter aditionally to any board related parameter are already defined in the board file.\nIf we move up in the boards.c file, you\u0026rsquo;ll see that it includes a boards.h header file. let\u0026rsquo;s jump into it.\nIn the boards.h header file, you\u0026rsquo;ll see lot of board definitions includes grayed (Not used, cause they are not defined).But, you\u0026rsquo;ll see that #include \u0026ldquo;pca10056.h\u0026rdquo; (our board file) is not.\nA Go To Defenition on that file will open it. This is where almost all your board pins are defined. Some pins are not included, cause they are not available as GPIO pins by default. Example : (P0.0), and (P0.1): they are connected to the 32.768 kHz crystal (nrf52840dk).\nPlease check your Dev-kit hardawre description for more details.\n  nRF52 DK hardware description.\n  nRF52833 DK hardware description.\n  nRF52840 DK hardware description.\n  The Dev-kit Buttons/Leds Pins: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // LEDs definitions for PCA10056\r#define LEDS_NUMBER 4\r\r#define LED_1 NRF_GPIO_PIN_MAP(0,13)\r#define LED_2 NRF_GPIO_PIN_MAP(0,14)\r#define LED_3 NRF_GPIO_PIN_MAP(0,15)\r#define LED_4 NRF_GPIO_PIN_MAP(0,16)\r#define LED_START LED_1\r#define LED_STOP LED_4\r\r#define LEDS_ACTIVE_STATE 0\r\r#define LEDS_LIST { LED_1, LED_2, LED_3, LED_4 }\r\r#define LEDS_INV_MASK LEDS_MASK\r\r#define BSP_LED_0 13\r#define BSP_LED_1 14\r#define BSP_LED_2 15\r#define BSP_LED_3 16\r\r#define BUTTONS_NUMBER 4\r\r#define BUTTON_1 11\r#define BUTTON_2 12\r#define BUTTON_3 24\r#define BUTTON_4 25\r#define BUTTON_PULL NRF_GPIO_PIN_PULLUP\r\r#define BUTTONS_ACTIVE_STATE 0\r\r#define BUTTONS_LIST { BUTTON_1, BUTTON_2, BUTTON_3, BUTTON_4 }\r\r#define BSP_BUTTON_0 BUTTON_1\r#define BSP_BUTTON_1 BUTTON_2\r#define BSP_BUTTON_2 BUTTON_3\r#define BSP_BUTTON_3 BUTTON_4   The pins numbring starts as follows :\n P0.0 to P0.31 \u0026mdash;\u0026mdash;-\u0026gt; 0 to 31 . P1.0 to P1.15 \u0026mdash;\u0026mdash;-\u0026gt; 32 to 47 .  The NRF_GPIO_PIN_MAP() function is used to convert the Px.y notation to a pin number.\nSo NRF_GPIO_PIN_MAP(0,13) = 13 , NRF_GPIO_PIN_MAP(1,0) = 32 and so on.\nIn our board file (pca10056.h):\n  We have 4 Leds and we can either use (LED_1, LED_2, LED_3, LED_4), or (BSP_LED_0, BSP_LED_1, BSP_LED_2, BSP_LED_3) as leds variables.\nThe LEDs are active LOW, means a LOW signal (0v) will turn them ON.\n  And we have 4 Buttons and we can either use (BUTTON_1, BUTTON_2, BUTTON3, BUTTON_4), or (BSP_BUTTON_0, BSP_BUTTON_1, BSP_BUTTON_2, BSP_BUTTON_3) as buttons variables.\nThe Buttons are active on LOW, a press will short the button pin to the ground (Pulled-up internally).\n  Buiding our application code: In this example code we\u0026rsquo;ll try to control each led with a button. So we\u0026rsquo;ll try to turn ON/OFF the LED1 with the Button1: a press turns it ON and a release turns it OFF, and so on for the others.\nHere is the example code, you can now press/release on any of your board buttons to control the related led.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  #include \u0026lt;stdbool.h\u0026gt;\r#include \u0026lt;stdint.h\u0026gt;\r#include \u0026#34;nrf_delay.h\u0026#34;\r#include \u0026#34;boards.h\u0026#34;\r\rint button1_state, button2_state, button3_state, button4_state;\r/**\r* @brief Function for application main entry.\r*/\rint main(void)\r{\r// Configure the buttons as inputs and Pull them Up\r nrf_gpio_cfg_input(BUTTON_1,NRF_GPIO_PIN_PULLUP);\rnrf_gpio_cfg_input(BUTTON_2,NRF_GPIO_PIN_PULLUP);\rnrf_gpio_cfg_input(BUTTON_3,NRF_GPIO_PIN_PULLUP);\rnrf_gpio_cfg_input(BUTTON_4,NRF_GPIO_PIN_PULLUP);\r// Configure the leds as outputs\r nrf_gpio_cfg_output(LED_1);\rnrf_gpio_cfg_output(LED_2);\rnrf_gpio_cfg_output(LED_3);\rnrf_gpio_cfg_output(LED_4);\r// Turn the LEDs OFF\r nrf_gpio_pin_set(LED_1); nrf_gpio_pin_set(LED_2); nrf_gpio_pin_set(LED_3); nrf_gpio_pin_set(LED_4);\rwhile (true)\r{\r// Read the buttons states  button1_state = nrf_gpio_pin_read(BUTTON_1);\rbutton2_state = nrf_gpio_pin_read(BUTTON_2);\rbutton3_state = nrf_gpio_pin_read(BUTTON_3);\rbutton4_state = nrf_gpio_pin_read(BUTTON_4);\rif(button1_state == 0) nrf_gpio_pin_clear(LED_1); // _clear() set the pin to LOW  else nrf_gpio_pin_set(LED_1); // _set() set the pin to HIGH \rif(button2_state == 0) nrf_gpio_pin_clear(LED_2);\relse nrf_gpio_pin_set(LED_2);\rif(button3_state == 0) nrf_gpio_pin_clear(LED_3);\relse nrf_gpio_pin_set(LED_3);\rif(button4_state == 0) nrf_gpio_pin_clear(LED_4);\relse nrf_gpio_pin_set(LED_4);\r}\r}   Notes: In the example we built, you can notice that all the control functions are in the while() loop, means that the SOC will keep reading the buttons pins all the time, and when ever a button is pressed it will turn the related led ON, and OFF when released.\nThe problem here is that the SOC will drain more power in this process, and this is a critical fearture here especillay for low power applications.\nA better way to acheive the same result with low power consumption, is by using interrupts.\n","description":"How to read the buttons states and control the leds.","id":2,"section":"tutorials","tags":null,"title":"Buttons and leds","uri":"/tutorials/buttons-and-leds/"}]