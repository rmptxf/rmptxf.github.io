[{"content":"In this Tutorial I will walk you throught all the necessary steps that you need to follow, in order to get started with the nRF5 development.\nStep1: Get a Development Kit In order to run/test your applications, you need to have a development kit. the dev-kit consists of a development board, where your targeted SOC (system on chip) is soldered to with all the necessary components needed for its proper working. Aditionally to some user-programmable buttons, leds, header pins\u0026hellip; so you can easilly and quikly test your applications. It also comes with a J-Link Debugger IC (Interface MCU) allowing programming and debugging both the on-board SoC, and external SoCs through the debug out headers.\nThe nRF5 consists of 3 series: the nRF51 series, the nRF52 series and the nRF53 series.\nThe nRF51 series: The nRF51 series features 4 SOCs :nRF51422, nRF51802, nRF51822, nRF51824.\nThe nRF51-DK supports the development for all the above SOCs.\n Onboard SOC : nRF51422. PCA number : PCA10028.  The nRF51-Dongle can also be used, but only for the nRF51822, nRF51422, nRF51824 SoCs.\nThe dongle comes with a On-Board SEGGER J-Link debugger, same as the Dev-kit. So you will not need to have an external debugger for flashing and debugging your applications. But as you note in the picture, the dongle has few pins exposed. So planing to use lot of pins might be of an issue. For that i suggest getting a dev-kit instead, then maybe get a dongle.\n Onboard SOC : nRF51422. PCA number : PCA10032.  The nRF52 series: The nRF52 series features 7 SOCs, that can be arranged into 3 categories : 1.nRF52832, nRF52810, nRF52805.\n2. nRF52833, nRF52820.\n3. nRF52840, nRF52811.\n1. nRF52832, nRF52810, nRF52805 : The nRF52-DK supports the development for the above SOCs.\n Onboard SOC : nRF52832. PCA number : PCA10040.  2. nRF52833, nRF52820 : The nRF52833-DK supports development for the above SOCs.\n Onboard SOC : nRF52833. PCA number : PCA10100.  3. nRF52840, nRF52811 : The nRF52840-DK supports development for the above SOCs.\n Onboard SOC : nRF52840. PCA number : PCA10056.  The nRF52840-Dongle is similar to the nRF52840-DK, but it doesn\u0026rsquo;t have an on-board debugger, so the debugging is not supported. The dongle can be programmed via USB using the nRFConnect desktop app.\n Onboard SOC : nRF52840. PCA number : PCA10059.  The nRF53 series: The nRF53 series features 1 SOC :nRF5340.\nThe nRF5340-PDK can be used to develop applications for the above SOC.\n Onboard SOC : nRF5340. PCA number : PCA10095.  Buying a Development kit:  Note: If you\u0026rsquo;re just getting started, I do recommend getting an nRF52 based development kit. If you think your application may need the USB peripheral feature, choose the nRF52840-DK, if not choose the nRF52-DK. Most of the nRF5 SDK examples are already supporting those two Development kits, So it will be easy to get started with.\n To buy a Development kit, refer to its Webpage and click on Buy now.\nStep2: Install the necessary software tools After getting your Development kit, you need to download and install the necessary software tools.\nThe nRF5 SDK The nRF5 SDK is a set of tools, modules, libraries, examples \u0026hellip; that are necessary for building applications for the nRF51 and nRF52 series.\nPlease Note that the nRF5_SDK does not support the development for the nRF53 series.\n Note: The nRF Connect SDK is the SDK that supports the nRF53 series.\n At the time of writing this tutorial 18th of August 2020, the latest version is nRF5_SDK_17.0.0_9d13099 (v17.0.0).\n Note: The nRF5_SDK v12.3.0 is the latest SDK to support the nRF51 family. So planing on using these SOCs will require using the nRF5_SDK v12.3.0 or older versions.\n Download your nRF5 SDK copy in the nRF-SDK Download page\nOnce you clicked on [Downloads] and choosed your version in the Changelog, move to the bottom of the page and click on [Download files].\n Note: To have an organized folder structure, consider extracting the nRF5_SDK Zip file in : For example: C:\\nRF\\nRF5_SDK\\v17.0.0\\. So all the SDK versions remain in the same folder.\n The Toolchain/IDE The latest version of the nRF5 SDK (v17) supports: ARM GCC, IAR, Keil5 and SES.\nSEGGER Embedded Studio (SES) is a Powerful IDE to use, also recomended by NordicSemi and offers a Free Commercial license for the use with its products.\n Note : Please note that the SDK v12.3.0 does not support the SEGGER TOOLCHAIN. It only supports the ARM GCC, IAR and Keil TOOLCHAINS.\n You can download the IDE in the SEGGER download page. It is available for: Windows 32/64 bit, Linux 32/64 bit and macOS.\nThe nRF Command Line Tools The nRF Command Line Tools is used for development, programming and debugging of Nordic\u0026rsquo;s nRF51, nRF52, nRF53 and nRF91 Series based SOCs using the Command line.\nDownload the latest vesrion for your OS in the nRF command line tools Download page.\nThe nRFConnect Desktop app The nRF Connect for Desktop is a cross-platform tool that enables testing and development with Nordic’s products including the nRF5 series. It can also be used to flash compiled hex files to the SOCs flash memory.\nDownload the latest version for your OS, in the NordicSemi Download Webpage.\nA BLE explorer app for your SmartPhone When developping a BLE based application, having a testing app installed in your SmartPhone will be very easy and fast in debugging your application before building the actual app.\nI found these apps very helpful:\n  BLE Scanner. The app is available for IOS and Android.\n  LightBlue® — Bluetooth Low Energy. The app is available for IOS and Android.\n  nRF Connect for Mobile. The app is available for IOS and Android.\n  ","description":"Getting started with nRF5 Development : The Software tools and the hardware that you need to have.","id":0,"section":"tutorials","tags":null,"title":"Getting started","uri":"https://nrf5dev.com/tutorials/getting-started/"},{"content":"After getting your development kit and installing all the necessary software tools, this should be the time to run/test some examples from the nRF5_SDK. I will be using the blinky example under the peripheral examples folder.\nOpen the blinky project with SES IDE: I have extracted the nRF5_SDK .Zip file in C:\\nRF\\nRF5_SDK\\v17.0.0\\, so the blinky example folder location will be in C:\\nRF\\nRF5_SDK\\v17.0.0\\examples\\peripheral\\blinky.\nIn this folder you will have 2 options:\n Directly upload the precompiled hex file (hex folder) (you will need nRFconnect desktop app for that). Open the source code files (pca\u0026hellip; folders). With this option you will be able to update and flash the application easilly using SES, and this is what I will be doing.  Which (pca \u0026hellip; folder) to open depends on your dev-kit.\n Note: This is also printed on Top of the On-board Debugger MCU of your Development kit.\n  Note: Most of the nRF5_SDK examples does not support the nRF52833-DK , but as the on-board SOC (nRF52833) is very similar to the (nRF52840) you can use the PCA10056 folder also for this dev-kit. But, you still need to :\n Change the board config from PCA10056 to PCA10100. Change the board definition in preprocessor definitions. Adjust the FLASH and RAM sizes.    Note: The nRF5_SDK v12.3.0 is the latest SDK to support the nRF51 family. So planing on using these SOCs will require using the nRF5_SDK v12.3.0 or older versions.\n For me, I have the nRF52840-DK, so i\u0026rsquo;ll open the PCA10056 folder, then blank (The example doesn\u0026rsquo;t use a Softdevice), then the IDE (SES), then open the EMPROJECT file. (SES) should then launch and load the blinky project source files.\nPlug your board: To connect your Dev-kit to your PC, use the Left USB connector (J2) . And please make sure you use a good USB cable (it is the most common source of issues like (board not detected, issues on uploading\u0026hellip;), unfortunaltely the dev-kit doesn\u0026rsquo;t come with one.\nHere is the nRF52840-DK with two USB connectors. the other usb connector (down to the right) (J3) is hard wired to the USB pins of the SOC, and serves as the USB link for applications such as a USB keyboard/mouse\u0026hellip; so this is the USB connector that you\u0026rsquo;ll be using to test/run these type of applications.\nThe Left USB connector (J2) is wired directly to the On-board Debugger, that in its turn is wired to both the on-board SOC and to the debug out ports.\nThe On-board Debugger automatically selects the SOC that will connect to. It will first check the debug out ports, if it didn\u0026rsquo;t detect any SOC on these ports, it will then switch to the on board SOC.\nIf you\u0026rsquo;re using the nRF52840-DK or the nRF52833-DK, make sure these switches are set to the default states:\n SW8: the power switch, is set to ON: You can use this switch to turn ON/OFF your dev-kit, without unpluging the USB cable. very handy in case of adding/updating some wiring connections on the fly. SW9: the nRF power source, is set to VDD: This is where to select the power source of the on board SOC. As we use the left usb connector, the SOC will get powered via VDD. SW6: make sure it is set to default: This switch disconnects the SOC from the On-board J-link Debugger if it is set to nRF ONLY.   Note: If you are using other development kits like the nRF52 DK, You will only have the power switch, so just turn that ON and you will be all set.\n Build and Run the blinky app: If everything is good, when you plug your dev-kit your OS should detect it and a green LED close to the On-board Debugger should light up. Now lets move into SES, where we have lunched our blinky example.\nYour SES user interface should look something like this:\nThe project\u0026rsquo;s Folder/Files are on the left side. Go to the Application folder, and open the main.c file (if it\u0026rsquo;s not already opened).\nGo to the Build menu and select Build and Run. This should build your application and flash it directly to your development kit SOC.\nIf the blinky app was uploaded successfully, you will notice the on-board LEDs turns ON one after the other, then turns back OFF one after the other at a fixed period of 1 second.\nUpdate the blinky app: 1. Update the blinking period: Now lets play with this example by updating the period of the blinking. let\u0026rsquo;s make it small a 0.5 second, so the leds blinks faster.\nIn the main() function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int main(void) { /* Configure board. */ bsp_board_init(BSP_INIT_LEDS); /* Toggle LEDs. */ while (true) { for (int i = 0; i \u0026lt; LEDS_NUMBER; i++) { bsp_board_led_invert(i); nrf_delay_ms(1000); } } }   You\u0026rsquo;ll notice that this function nrf_delay_ms(), is the responsible for the delay between the ON and OFF of the leds (the blinking). Its value is set to 1000 ms = 1 second. Will update it to 0.5 second = 500 ms.\n1  nrf_delay_ms(500); // changed the 1000 to 500  \nNow, save your main.c file with a Left_Control+S (if you are on windows), or just open the File menu and hit Save main.c or Save All (this will save any unsaved modified files).\nNext, go to the Build menu, and hit Build And Run.\nNow have a look at the LEDs, the blinking period should be updated and the ON/OFF sequence should be faster.\n2. Update the blinking sequence: Now lets change the blinking sequence to start from LED4 to LED1. The bsp_board_led_invert(i) function inverts the LEDs based on there index. The index starts from 0 to 3. So the LED1 index is 0, and the LED4 will be 3.\nFor that, the for() loop should start from 3 to 0.\nThe LEDS_NUMBER is the total LEDs on the boards, which is 4.\nSo we should start from i= LEDS_NUMBER-1 with the condition of i \u0026gt;= 0 so we can still execute the 0 index.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int main(void) { /* Configure board. */ bsp_board_init(BSP_INIT_LEDS); /* Toggle LEDs. */ while (true) { for (int i = LEDS_NUMBER-1; i \u0026gt;= 0; i--) { bsp_board_led_invert(i); nrf_delay_ms(1000); } } }   3. LEDs all Blinking at the same time: Now lets make all the LEDs blinks at the same time.\nLooking into the boards.c file -that you can access under Borad definition folder in the Project files to the left- there are these two functions bsp_board_leds_on() and bsp_board_leds_off. These two function can turn On/Off all the LEDs in the Board. The new main()function would look like:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  int main(void) { /* Configure board. */ bsp_board_init(BSP_INIT_LEDS); /* Toggle all the LEDs. */ while (true) { bsp_board_leds_on(); nrf_delay_ms(1000); bsp_board_leds_off(); nrf_delay_ms(1000); } }   4. Blink a specific LED: Now lets blink a specific LED.\nLooking again into the boards.c file, there are these two functions bsp_board_led_on(uint32_t led_idx) and bsp_board_led_off(uint32_t led_idx). These two function can turn On/Off a specific LED, based on its index. Let\u0026rsquo;s blink the LED1 which its index is 0.\n Note: If you try to use an out of range index ( \u0026gt; LEDS_NUMBER-1), the application execution will assert.\n The new main()function would look like:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  int main(void) { /* Configure board. */ bsp_board_init(BSP_INIT_LEDS); /* Toggle all the LEDs. */ while (true) { bsp_board_led_on(0); nrf_delay_ms(1000); bsp_board_led_off(0); nrf_delay_ms(1000); } }    Note: The borad.c file includes many other functions that you can use to control the LEDs states as also read the Buttons states.\n ","description":"Test the peripheral/blinky example.","id":1,"section":"tutorials","tags":null,"title":"Blinky Test","uri":"https://nrf5dev.com/tutorials/test-blinky-app/"},{"content":"Your nRF52 development kit already comes with 4 user-programmable buttons and 4 leds built in.\nIn this tutorial we\u0026rsquo;ll be looking into how to read these buttons states and control the leds. This should give you a better understanding on how to read and control pins states.\nGetting started: For building the testing code, we\u0026rsquo;ll be starting with the blinky project located under the peripheral examples.\ni\u0026rsquo;m using the nRF52840-DK (PCA10056), so i\u0026rsquo;ll launch the EM PROJECT FILE in ../examples/peripheral/blinky/pca10056/blank/ses. This should luanch the SES IDE, and load the blinky project files.\nNext, open your main.c file under the Application folder in the SES project file explorer on the left and scroll down to the main() function.\nIt should look like :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int main(void) { /* Configure board. */ bsp_board_init(BSP_INIT_LEDS); /* Toggle LEDs. */ while (true) { for (int i = 0; i \u0026lt; LEDS_NUMBER; i++) { bsp_board_led_invert(i); nrf_delay_ms(1000); } } }   Before jumping into the code, I first want you to know about this handy feature in SES:\n On any function or included header file, you can jump into the code behind it by using the Go To Definition or Go To Declaration options available in the Mouse right click menu. And you can also keep doing it when ever you need to. If you get lost and want to come back, use the Arrow keys on the top left.\n In our main() we have this function bsp_board_led_invert(i);, this function is the responsible for the LED state inverting. lets see the code behind it using the SES Go to Definition feature.\nThis will open the boards.c file, and you can see the code behind that function there. So this is the function that actualy gets executed nrf_gpio_pin_toggle(m_board_led_list[led_idx]), after it made sure the led (index) we try to invert its state is less than the LEDS_NUMBER. ASSERT(led_idx \u0026lt; LEDS_NUMBER);\nThe LEDS_NUMBER is how many LEDs we have defined. This parameter aditionally to any board related parameter are already defined in the board file.\nIf we move up in the boards.c file, you\u0026rsquo;ll see that it includes a boards.h header file. let\u0026rsquo;s jump into it.\nIn the boards.h header file, you\u0026rsquo;ll see lot of board definitions includes grayed (Not used, cause they are not defined).But, you\u0026rsquo;ll see that #include \u0026ldquo;pca10056.h\u0026rdquo; (our board file) is not.\nA Go To Defenition on that file will open it. This is where almost all your board pins are defined. Some pins are not included, cause they are not available as GPIO pins by default. Example : (P0.0), and (P0.1): they are connected to the 32.768 kHz crystal (nrf52840dk).\nPlease check your Dev-kit hardawre description for more details.\n  nRF52 DK hardware description.\n  nRF52833 DK hardware description.\n  nRF52840 DK hardware description.\n  The Dev-kit Buttons/Leds Pins:  pca10056.h file.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // LEDs definitions for PCA10056 #define LEDS_NUMBER 4  #define LED_1 NRF_GPIO_PIN_MAP(0,13) #define LED_2 NRF_GPIO_PIN_MAP(0,14) #define LED_3 NRF_GPIO_PIN_MAP(0,15) #define LED_4 NRF_GPIO_PIN_MAP(0,16) #define LED_START LED_1 #define LED_STOP LED_4  #define LEDS_ACTIVE_STATE 0  #define LEDS_LIST { LED_1, LED_2, LED_3, LED_4 }  #define LEDS_INV_MASK LEDS_MASK  #define BSP_LED_0 13 #define BSP_LED_1 14 #define BSP_LED_2 15 #define BSP_LED_3 16  #define BUTTONS_NUMBER 4  #define BUTTON_1 11 #define BUTTON_2 12 #define BUTTON_3 24 #define BUTTON_4 25 #define BUTTON_PULL NRF_GPIO_PIN_PULLUP  #define BUTTONS_ACTIVE_STATE 0  #define BUTTONS_LIST { BUTTON_1, BUTTON_2, BUTTON_3, BUTTON_4 }  #define BSP_BUTTON_0 BUTTON_1 #define BSP_BUTTON_1 BUTTON_2 #define BSP_BUTTON_2 BUTTON_3 #define BSP_BUTTON_3 BUTTON_4  \n The pins numbring is as follows:\n  P0.0 to P0.31 \u0026mdash;\u0026mdash;\u0026gt; 0 to 31 . P1.0 to P1.15 \u0026mdash;\u0026mdash;\u0026gt; 32 to 47 .   The NRF_GPIO_PIN_MAP() function is used to convert the Px.y notation to a pin number.\nSo NRF_GPIO_PIN_MAP(0,13) = 13 , NRF_GPIO_PIN_MAP(1,0) = 32 and so on.\nIn our board file (pca10056.h):\n  We have 4 Leds and we can either use (LED_1, LED_2, LED_3, LED_4), or (BSP_LED_0, BSP_LED_1, BSP_LED_2, BSP_LED_3) as leds variables.\nThe LEDs are active LOW, means a LOW signal (0v) will turn them ON.\n  And we have 4 Buttons and we can either use (BUTTON_1, BUTTON_2, BUTTON3, BUTTON_4), or (BSP_BUTTON_0, BSP_BUTTON_1, BSP_BUTTON_2, BSP_BUTTON_3) as buttons variables.\nThe Buttons are active on LOW, a press will short the button pin to the ground (Pulled-up internally).\n  Buiding our application code: In this example code we\u0026rsquo;ll try to control each led with a button. So we\u0026rsquo;ll try to turn ON/OFF the LED1 with the Button1: a press will turn it ON and a release will turn it OFF, and same for the others.\nHere is the example code. You can now press/release on any of your development kit buttons to control the related led.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  #include \u0026lt;stdbool.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026#34;nrf_delay.h\u0026#34;#include \u0026#34;boards.h\u0026#34; int button1_state, button2_state, button3_state, button4_state; /** * @brief Function for application main entry. */ int main(void) { // Configure the buttons as inputs and Pull them Up  nrf_gpio_cfg_input(BUTTON_1,NRF_GPIO_PIN_PULLUP); nrf_gpio_cfg_input(BUTTON_2,NRF_GPIO_PIN_PULLUP); nrf_gpio_cfg_input(BUTTON_3,NRF_GPIO_PIN_PULLUP); nrf_gpio_cfg_input(BUTTON_4,NRF_GPIO_PIN_PULLUP); // Configure the leds as outputs  nrf_gpio_cfg_output(LED_1); nrf_gpio_cfg_output(LED_2); nrf_gpio_cfg_output(LED_3); nrf_gpio_cfg_output(LED_4); // Turn the LEDs OFF  nrf_gpio_pin_set(LED_1); nrf_gpio_pin_set(LED_2); nrf_gpio_pin_set(LED_3); nrf_gpio_pin_set(LED_4); while (true) { // Read the buttons states  button1_state = nrf_gpio_pin_read(BUTTON_1); button2_state = nrf_gpio_pin_read(BUTTON_2); button3_state = nrf_gpio_pin_read(BUTTON_3); button4_state = nrf_gpio_pin_read(BUTTON_4); if(button1_state == 0) nrf_gpio_pin_clear(LED_1); // _clear() set the pin to LOW  else nrf_gpio_pin_set(LED_1); // _set() set the pin to HIGH  if(button2_state == 0) nrf_gpio_pin_clear(LED_2); else nrf_gpio_pin_set(LED_2); if(button3_state == 0) nrf_gpio_pin_clear(LED_3); else nrf_gpio_pin_set(LED_3); if(button4_state == 0) nrf_gpio_pin_clear(LED_4); else nrf_gpio_pin_set(LED_4); } }    Notes: In the example we built, you can notice that all the control functions are in the while() loop, means that the SOC will keep reading the buttons pins all the time, and whenever a button is pressed it will turn the related led ON, and OFF when released.\nThe problem here is that the SOC will drain lot of power in this process, and this is a critical fearture for battery powered applications.\nA better way to acheive the same result with low power consumption, would be by using interrupts.\n ","description":"How to read the buttons states and control the leds with the nRF5.","id":2,"section":"tutorials","tags":null,"title":"Buttons and leds","uri":"https://nrf5dev.com/tutorials/buttons-and-leds/"},{"content":"In this tutorial I will be looking into how to read analog voltages using the nRF52 series of SOCs.\nAnalog Inputs : The nrf52 series of SOCs are equiped with an 8 channel ADC, in where the Pins are assigned to the following GPIOs :\nTest example : In this test example I will be using a potentiometer wired to the AIN1 which is the GPIO 3.\nFor the firmware, I will be using the Segger toolchain and will start with the saadc example located under examples/peripheral in the nRF5 sdk.\nOnce you located the saadc example, open your SOC\u0026rsquo;s related project file (pca\u0026hellip;.) then blank, then ses then execute the saadc_pca\u0026hellip;. file. Segger IDE should lunch and open the project main.c file.\nIn the main.c file, locate this function (line 152-153):\n1 2  nrf_saadc_channel_config_t channel_config = NRF_DRV_SAADC_DEFAULT_CHANNEL_CONFIG_SE(NRF_SAADC_INPUT_AIN0);   and change the NRF_SAADC_INPUT_AIN0 to NRF_SAADC_INPUT_AIN1.\nThen change this function :\n1 2 3  void saadc_callback(nrf_drv_saadc_evt_t const * p_event) { }   to :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  void saadc_callback(nrf_drv_saadc_evt_t const * p_event) { if (p_event-\u0026gt;type == NRF_DRV_SAADC_EVT_DONE) { ret_code_t err_code; uint16_t saadc_samples = 0; uint16_t saadc_read_value = 0; uint16_t saadc_read_voltage = 0; err_code = nrf_drv_saadc_buffer_convert(p_event-\u0026gt;data.done.p_buffer, SAMPLES_IN_BUFFER); APP_ERROR_CHECK(err_code); for (uint8_t i = 0; i \u0026lt; SAMPLES_IN_BUFFER; i++) { // as we\u0026#39;re using just one saadc channel  // all the samples will be for that channel  saadc_samples += p_event-\u0026gt;data.done.p_buffer[i]; } // this will add more accuracy  saadc_read_value = saadc_samples/SAMPLES_IN_BUFFER; // converting the saadc read value to a voltage  saadc_read_voltage = ADC_RESULT_IN_MILLI_VOLTS(saadc_read_value); NRF_LOG_INFO(\u0026#34;ADC event number: %d\u0026#34;, (int)m_adc_evt_counter); NRF_LOG_INFO(\u0026#34;ADC read value: %d\u0026#34;, saadc_read_value); NRF_LOG_INFO(\u0026#34;ADC read voltage: %d mV\u0026#34;, saadc_read_voltage); m_adc_evt_counter++; } }   Then add the voltage converstion formulat to your application definitions. The application uses a 12bit resolution by default, so the formulat would be :\n1 2 3  // 12bit // V(P) = RESULT x REFERENCE / ( GAIN x RESOLUTION) = RESULT x (600 / (1/6 x 2^(12)) = ADC_RESULT x 0.87890625; #define ADC_RESULT_IN_MILLI_VOLTS(ADC_RESULT) ((ADC_RESULT * 0.87890625))   If you want to use a 14bit resolution, which is possible when you\u0026rsquo;re enabling just one channel. You can do that in the sdk_config.h, or app_config.h if you have set that in your application.\nYou need to change these two definitons :\n1 2 3 4 5  // \u0026lt;o\u0026gt; NRFX_SAADC_CONFIG_RESOLUTION - Resolution #define NRFX_SAADC_CONFIG_RESOLUTION 2 // 12bit  // \u0026lt;o\u0026gt; SAADC_CONFIG_RESOLUTION - Resolution #define SAADC_CONFIG_RESOLUTION 2 // 12bit   Then you need to update the conversion formulat to :\n1 2 3  // 14bit // V(P) = RESULT x REFERENCE / ( GAIN x RESOLUTION) = RESULT x (600 / (1/6 x 2^(14)) = ADC_RESULT x 0.2197265625; #define ADC_RESULT_IN_MILLI_VOLTS(ADC_RESULT) ((ADC_RESULT * 0.2197265625))   Hope that helps,\nIf you have any questions about this tutorial, please drop them in the comments section bellow.\n","description":"How to read analog voltages using nRF52 based SOCs.","id":3,"section":"tutorials","tags":null,"title":"Analog reading","uri":"https://nrf5dev.com/tutorials/analog-reading/"}]